<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Chart Vis.</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.15.349/pdf.min.js"></script>
    <style>
        table {
            width: 50%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        th,
        td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }

        th {
            background-color: #f4f4f4;
        }

        .hidden {
            display: none;
        }

        .chart-container {
            width: 100%;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }

        canvas {
            max-width: 500px;
            width: 100%;
            max-height: 400px;
        }

        body {
            /* display: flex; */
            justify-content: center;
            /* Centers content horizontally */
            text-align: center;
            /* Optional, to center text inside containers */
            margin: 0;
            /* Remove default margin */
        }

        #charts-container {
            display: flex;
            flex-direction: column;
            /* Stack chart and table vertically */
            align-items: center;
            /* Center both chart and table horizontally */
        }

        table {
            width: 50%;
            /* Set the width of the table */
            margin-top: 20px;
            /* Add some space between chart and table */
            border-collapse: collapse;
        }

        th,
        td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }

        th {
            background-color: #f4f4f4;
        }

        /* General Reset */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial', sans-serif;
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            background-color: #f7f9fc;
            /* Soft background color */
            color: #333;
            /* Neutral text color */
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }

        /* Headings */
        h1 {
            font-size: 2rem;
            color: #2a5d8f;
            /* Accent color */
            margin-bottom: 10px;
        }

        p {
            font-size: 1rem;
            margin-bottom: 20px;
        }

        /* File Upload */
        input[type="file"] {
            padding: 10px;
            border: 1px solid #d1d9e6;
            border-radius: 5px;
            background-color: #fff;
            color: #555;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        input[type="file"]:hover {
            background-color: #eef3f9;
            border-color: #b0c4de;
        }

        /* Charts Container */
        #charts-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 800px;
            margin-top: 20px;
        }

        canvas {
            max-width: 100%;
            height: auto;
            border: 1px solid #d1d9e6;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            background-color: #ffffff;
            padding: 10px;
        }

        /* Table Styling */
        table {
            width: 100%;
            max-width: 800px;
            margin-top: 20px;
            border-collapse: collapse;
            border: 1px solid #d1d9e6;
            background-color: #fff;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border-radius: 10px;
            overflow: hidden;
        }

        th,
        td {
            padding: 12px 15px;
            text-align: center;
            border-bottom: 1px solid #e8eff5;
            font-size: 1rem;
        }

        th {
            background-color: #2a5d8f;
            color: #ffffff;
            font-weight: bold;
        }

        tr:nth-child(even) {
            background-color: #f2f7fc;
        }

        tr:hover {
            background-color: #eef3f9;
        }

        /* Button Styling */
        button {
            padding: 10px 20px;
            font-size: 1rem;
            color: #ffffff;
            background-color: #2a5d8f;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #184a6d;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            h1 {
                font-size: 1.5rem;
            }

            p {
                font-size: 0.9rem;
            }

            input[type="file"] {
                width: 100%;
                font-size: 0.9rem;
            }

            table,
            canvas {
                width: 100%;
            }

            th,
            td {
                font-size: 0.9rem;
            }
        }
    </style>
</head>

<body>
    <h1>MyChart Test Visualization</h1>
    <p>Upload an HTML file to see infographics.</p>
    <input type="file" id="uploadHtml" accept="text/html">
    <!-- <input type="file" id="uploadPdf" accept="application/pdf"> -->

    <!-- Container for charts -->
    <div id="charts-container" class="chart-container">
    </div>
    <!-- Table to display extracted data -->
    <table id="dataTable" class="hidden">
        <thead>
            <tr>
                <th>Date</th>
                <th>Test</th>
                <th>Result</th>
                <th>Reference Range</th>
                <th>Normalcy</th>
                <th>Note/Annotation</th>
                <th>Test Type</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
            </tr>
            <!-- Data will be dynamically inserted here -->
        </tbody>
    </table>

    <!-- <canvas id="chartCanvas" width="400" height="200"></canvas> -->



    <script>
        const pdfjsLib = window['pdfjs-dist/build/pdf'];
        let chart;

        // Initialize the chart with placeholder data
        function initializeChart() {
            const ctx = document.getElementById('chartCanvas').getContext('2d');
            chart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Placeholder 1', 'Placeholder 2', 'Placeholder 3'],
                    datasets: [{
                        label: 'Initial Data',
                        data: [0, 0, 0], // Placeholder data
                        backgroundColor: 'rgba(75, 192, 192, 0.2)',
                        borderColor: 'rgba(75, 192, 192, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: { beginAtZero: true }
                    },
                    plugins: {
                        annotation: {
                            annotations: {
                                referenceRange: {
                                    type: 'box',
                                    yMin: 0.5,
                                    yMax: 1.5,
                                    backgroundColor: 'rgba(75, 192, 192, 0.2)', // Light translucent color
                                }
                            }
                        }
                    }
                }
            });
        }

        // Update the HTML table with extracted data
        function updateTable(data) {
            const table = document.getElementById('dataTable');
            const tbody = table.querySelector('tbody');
            tbody.innerHTML = ''; // Clear existing rows

            data.forEach(r => {
                const row = document.createElement('tr');
                r.forEach((el) => {
                    row.innerHTML += `<td>${el}</td>`;
                });
                for (let i = r.length; i < 6; i++) {
                    row.innerHTML += `<td></td>`;
                }
                tbody.appendChild(row);
            });


            table.classList.remove('hidden'); // Show the table
        }

        // Function to group test data by test name
        function groupByTestName(data) {
            const groupedData = {};

            data.forEach((row) => {
                const [dateTime, testName, result] = row;
                if (!groupedData[testName]) {
                    groupedData[testName] = [];
                }
                groupedData[testName].push({ dateTime, result: parseFloat(result) });
            });

            return groupedData;
        }

        // Function to create a bar chart for each test
        function createChartForTest(testName, testData) {
            const container = document.getElementById('charts-container');

            const dates = testData.map(item => item.dateTime.substring(0, 10));
            const results = testData.map(item => item.result);

            const canvas = document.createElement('canvas');
            container.appendChild(canvas);

            new Chart(canvas, {
                type: 'bar',
                data: {
                    labels: dates,
                    datasets: [{
                        label: testName,
                        data: results,
                        backgroundColor: 'rgba(75, 192, 192, 0.2)',
                        borderColor: 'rgba(0,0,0,1)',
                        borderWidth: 1,
                        backgroundColor: function (context) {
                            const value = context.raw;
                            if (value < 0.5 || value > 1.5) return 'rgba(255, 206, 86, 0.8)'; // Red
                            // if (value === 0.5 || value === 1.5) return 'rgba(255, 206, 86, 0.8)'; // Yellow
                            return 'rgba(75, 192, 192, 0.8)'; // Green
                        }
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        x: { type: 'category' }, // Treat dates as categories
                        y: { beginAtZero: true }
                    },
                    plugins: {
                        annotation: {
                            annotations: {
                                referenceRange: {
                                    type: 'box',
                                    yMin: 0.5,
                                    yMax: 1.5,
                                    backgroundColor: 'rgba(75, 192, 192, 0.2)', // Light translucent color
                                }
                            }
                        }
                    }
                }
            });
        }

        // Parse the uploaded HTML file
        document.getElementById('uploadHtml').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function () {
                const parser = new DOMParser();
                const doc = parser.parseFromString(reader.result, 'text/html');

                // Extract table data (modify selectors based on your input HTML structure)
                const rows = Array.from(doc.querySelectorAll("table tr[colspan='5']")).map(tr =>
                    Array.from(tr.querySelectorAll('td, th')).map(cell => cell.textContent.trim())
                );
                // Filter rows (remove header row or invalid rows if necessary)
                const filteredRows = rows.map((v, i) => {
                    var spl = v[1].split(';')
                    if (spl.length > 1) {
                        v[1] = spl[0]
                        v.push(spl[1])
                    } else {
                        v.push('')
                    }
                    if (spl.length > 2) {
                        console.log("NOTICE - ")
                        console.log(spl)
                    }
                    if (v.length === 6) {
                        v = v.slice(0, 4).concat(['']).concat(v.slice(4, v.length))
                    }
                    if (v.length < 7) {
                        for (let i = v.length; i < 7; i++) {
                            v.push('')
                        }
                    }
                    return v
                });
                //.filter(row =>
                // row.length === 3 && // Ensure row has 3 columns
                // !isNaN(Date.parse(row[0])) && // Ensure first column is a valid Date/Time
                // !isNaN(parseFloat(row[2])) // Ensure third column is a valid number
                // );

                // Update the table and chart with the parsed data
                updateTable(filteredRows);
                // updateChart(filteredRows);
                // Group by test name
                const groupedData = groupByTestName(filteredRows);

                // Generate a chart for each test
                Object.keys(groupedData).forEach(testName => {
                    createChartForTest(testName, groupedData[testName]);
                });
            };

            reader.readAsText(file);
        });

        document.getElementById('uploadPdf').addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const fileReader = new FileReader();
            fileReader.onload = async function () {
                const typedArray = new Uint8Array(this.result);
                const pdf = await pdfjsLib.getDocument(typedArray).promise;

                const allTextContent = [];
                const allRows = [];
                var wholeString = "";

                // Loop through all pages
                for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                    const page = await pdf.getPage(pageNum);
                    const textContent = await page.getTextContent();

                    // Combine text items for the current page
                    const pageText = textContent.items.map(item => item.str).join('\t');
                    allTextContent.push(pageText);
                    wholeString += "\n" + pageText

                    // Group the text into rows of data
                    allRows.push(...groupTextIntoCells(textContent.items));
                }

                let valRows = [];
                let curRow = [];
                for (let i = 0; i < allRows.length; i++) {
                    if (isValidDateTimeFormat(allRows[i][0])
                        || allRows[i][0].includes('Observation')
                    ) {
                        valRows.push(curRow)
                        curRow = allRows[i]
                    }
                    else if (allRows[i][0] == '') {
                        console.log('check row: ' + allRows[i])
                    }
                    else {
                        allRows[i].forEach((element, index) => {
                            if (curRow.length > index) {
                                curRow[index] += ' ' + element
                            }
                        });
                    }
                }

                // Process rows: Extract Date/Time, Test, and Result
                const validRows = valRows.filter(row => {
                    var wordAppears = false;
                    row.forEach(element => {
                        if ((element.includes('Creatinine')
                            || element.includes('Glomerular')
                            || element.includes('Mean Corpuscular Hemo')
                            || element.includes('Erythrocytes')
                            || element.includes('Glucose')
                            || element.includes('Volume')
                            || element.includes('pH')
                            || element.includes('Ketones')
                            || element.includes('Lactate')
                            || element.includes('Promyel')
                        ) && !element.includes('Procedure Name')
                        ) {
                            wordAppears = true;
                        }
                    });
                    // for (let i = 0; i < row.length; i++) {
                    //     if (row[i] == '') {
                    //         row.splice(i, 1)
                    //     }
                    // }
                    if (wordAppears && (!isValidDateTimeFormat(row[0]) || !isValidNumber(row[2]))) {
                        console.log("warning: row matches keyword but row not included: ")
                        console.log(row)
                    }
                    return isValidDateTimeFormat(row[0]) && isValidNumber(row[2])
                })
                // ).map(row => [row[0], row[1].replace('; Blood', '').replace('; RBC', ''), row[2]]);

                console.log(validRows.length)
                updateTable(validRows);

                // Group by test name
                const groupedData = groupByTestName(validRows);

                // Generate a chart for each test
                Object.keys(groupedData).forEach(testName => {
                    createChartForTest(testName, groupedData[testName]);
                });
            };

            fileReader.readAsArrayBuffer(file);
        });

        // Function to group text items into rows and cells based on their Y-coordinate and proximity
        function groupTextIntoCells(items) {
            const rowTolerance = 5;
            const cellTolerance = 10;

            const rows = [];
            items.sort((a, b) => b.transform[5] - a.transform[5]); // Sort by Y-coordinate (descending)

            items.forEach((item) => {
                const y = item.transform[5];
                const x = item.transform[4];

                // Find the appropriate row (if Y-coordinate matches)
                let row = rows.find(r => Math.abs(r.y - y) <= rowTolerance);
                if (!row) {
                    row = { y, cells: [] };
                    rows.push(row);
                }

                // Find the appropriate cell (if X-coordinate matches)
                let cell = row.cells.find(c => Math.abs(c.x - x) <= cellTolerance);
                if (!cell) {
                    cell = { x, content: '' };
                    row.cells.push(cell);
                }

                // Append text to the cell's content
                cell.content += item.str + ' ';
            });

            // Sort rows by their Y-coordinate (ascending for reading order)
            rows.sort((a, b) => a.y - b.y);

            // Extract the row content as an array of strings
            return rows.map(row => {
                row.cells.sort((a, b) => a.x - b.x); // Sort cells by X-coordinate
                return row.cells.map(cell => cell.content.trim()); // Return trimmed cell content
            });
        }

        function isValidDateTimeFormat(text) {
            const dateTimeRegex = /^\d{4}-\d{2}-\d{2}/;
            return text && text.length >= 10 && dateTimeRegex.test(text.substring(0, 10));
        }

        function isValidNumber(text) {
            const numberRegex = /^-?\d+(\.\d+)?$/;
            return numberRegex.test(text);
        }

        // Initialize the chart on page load
        // window.onload = function() {
        //     initializeChart();
        // };
    </script>
</body>

</html>